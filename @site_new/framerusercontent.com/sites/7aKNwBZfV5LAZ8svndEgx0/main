
        import * as React from "react"
        import * as ReactDOM from "react-dom/client"
        import * as Framer from "framer"

        const routes = {augiA20Il: {elements: {BtokuO8Lw: "logos", fHnbTyNwO: "features-bento", Mo0uZZjYz: "about", ovD3wZLbe: "footer", s_S8SY_3g: "hero"}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/j0Xv6QCdBa3juZcSwXSE/gcwKTfkTn0jeh5Cghaov/augiA20Il.js")), path: "/"}, ANGvDl6hG: {elements: {}, page: Framer.lazy(() => import("https://framerusercontent.com/modules/9HPG4V7BNFtofPrWqLuX/GObR5u4P8z16PYz3duuz/ANGvDl6hG.js")), path: "/404"}}
        const locales = [{code: "en", id: "default", name: "English", slug: ""}]

        export async function getPageRoot({ routeId, pathVariables, localeId }) {
            // We don't want the initial render to immediately have to suspend.
            await routes[routeId].page.preload()

            const content = React.createElement(
                Framer.PageRoot,
                {
                    isWebsite: true,
                    routeId,
                    pathVariables,
                    routes,
                    collectionUtils: {},
                    framerSiteId: "8f201206176aa4319bc71f01888809f33d66455f05682cb3247a66cc96f73f9c",
                    notFoundPage: Framer.lazy(() => import("/framerusercontent.com/modules/9HPG4V7BNFtofPrWqLuX/GObR5u4P8z16PYz3duuz/ANGvDl6hG.js")),
                    isReducedMotion: undefined,
                    localeId,
                    locales,
                    preserveQueryParams: undefined,
                }
            )

            const contentWithFeaturesContext = React.createElement(
                Framer.LibraryFeaturesProvider,
                {
                    children: content,
                    value: {enableAsyncURLUpdates: false, useGranularSuspense: false}
                }
            )

            
            const page = React.createElement(Framer.PageEffectsProvider, {
                children: contentWithFeaturesContext,
                value: {global: {enter: {opacity: 0, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition: {damping: 80, delay: 0, duration: 0.2, ease: [0.27, 0, 0.51, 1], mass: 1, stiffness: 400, type: "spring"}, x: "0px", y: "0px"}}, routes: {}}
            })

            return page
        }

        const isBrowser = typeof document !== "undefined"
        if (isBrowser) {
            window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => {
                return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' })
            }

            // A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it
            window.process = {
                ...window.process,
                env: {
                    ...(window.process ? window.process.env: undefined),
                    NODE_ENV: "production"
                }
            }

            // Fallback support for stack gaps
            Framer.installFlexboxGapWorkaroundIfNeeded()

            window.__framer_events = window.__framer_events || []
        }

        function track() {
            if (!isBrowser) return
            window.__framer_events.push(arguments)
        }

        function callWhenDOMReady(callback) {
            if (!isBrowser) return
            if (document.readyState === "interactive" || document.readyState === "complete") {
                callback()
            } else {
                // Note that we’re listening to readystatechange instead of DOMContentLoaded because the latter
                // doesn’t accurately reflect when the DOM is ready. Specifically, it’s delayed by scripts with
                // a defer attribute.
                document.addEventListener("readystatechange", () => {
                    if (document.readyState === "interactive") callback()
                })
            }
        }

        callWhenDOMReady(async function() {
            try {
                const container = document.getElementById("main")

                let routeId, localeId, pathVariables, breakpoints, shouldHydrate = false
                if ("framerHydrateV2" in container.dataset) {
                    const routeData = JSON.parse(container.dataset.framerHydrateV2)
                    routeId = routeData.routeId
                    localeId = routeData.localeId
                    pathVariables = routeData.pathVariables
                    breakpoints = routeData.breakpoints
                    shouldHydrate = true
                } else {
                    const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname), true, locales)
                    routeId = routeData.routeId
                    localeId = routeData.localeId
                    pathVariables = routeData.pathVariables
                }

                const page = await getPageRoot({ routeId, localeId, pathVariables })

                function handleRecoverableError(error, errorInfo) {
                    const componentStack = errorInfo?.componentStack
                    console.warn("Recoverable error during hydration. Please check any custom code or code overrides to fix server/client mismatches.", error, componentStack)

                    // we only want to collect 1%, because this can be quite noisy (floods the data pipeline)
                    if (Math.random() > 0.01) return
                    track("published_site_load_recoverable_error", {
                        message: String(error),
                        componentStack, // componentStack is more useful
                        stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null,
                    })
                }

                if (shouldHydrate) {
                    Framer.withPerformanceMarks("framer-rewrite-breakpoints", () => {
                        Framer.removeHiddenBreakpointLayersV2(breakpoints)
                        window.__framer_onRewriteBreakpoints?.(breakpoints)
                    })

                    React.startTransition(() => {
                        Framer.markHydrationStart()
                        Framer.setInitialHydrationState()
                        if (true) Framer.turnOffReactEventHandling()

                        ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleRecoverableError })
                    })
                } else {
                    ReactDOM.createRoot(container, { onRecoverableError: handleRecoverableError }).render(page)
                }
            } catch (error) {
                track("published_site_load_error", {
                    message: String(error),
                    stack: error instanceof Error && typeof error.stack === "string" ? error.stack : null
                })
                throw error
            }
        })

        
    